<html>
<head>
    <title>Derek Costello Practice 9.4</title>
</head>
<body>

    <canvas id="myCanvas"></canvas>

<script type="module">
import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
import { OrbitControls } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/OrbitControls.js";

/**
 * Utility Methods
 */ 

// Objects & Functions
// Gets a random number
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}

// Gets a random integer
// https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range
function getRandomArbitraryInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Shuffles an array
// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
function shuffle(array) {
  let currentIndex = array.length,  randomIndex;

  // While there remain elements to shuffle.
  while (currentIndex != 0) {

    // Pick a remaining element.
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex], array[currentIndex]];
  }

  return array;
}

/**
 * Determines if an array has duplicate objects
 * https://stackoverflow.com/questions/7376598/in-javascript-how-do-i-check-if-an-array-has-duplicate-values
 */
function hasDuplicates(a) {

    const noDups = new Set(a);
    return a.length !== noDups.size;
}


// Define scene
var scene = new THREE.Scene();

// Camera
var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.set(0, 0, 10);
camera.lookAt( new THREE.Vector3(0.0,0.0,0.0));
scene.add( camera );

// Define renderer
var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;

const controls = new OrbitControls(camera, renderer.domElement);

function Tree(start, recursions) {
    this.group = new THREE.Group();
    this.instructions = "";
    this.rules = function (args){
        if(args[0] == "B") {
            if(args[1] <= 1500) // 15% chance of BB
                return "BB";
            else if(args[1] > 1500 && args[1] <= 3625) // 16.25% chance for each other rule
                return "B[+F]";
            else if(args[1] > 3625 && args[1] <= 5750)
                return "B[-F]";
            else if(args[1] > 5750 && args[1] <= 7875)
                return "B[^F]";
            else if(args[1] > 7875 && args[1] <= 10000)
                return "B[%F]";
        }
        else if(args[0] == "F") {
            if(args[1] <= 3333) // 33.33% chance of F
                return "F";
            else if(args[1] > 3333 && args[1] <= 4444) // 11.11% chance for each other rule
                return "B[+F]-F";
            else if(args[1] > 4444 && args[1] <= 5555)
                return "B[+F]^F";
            else if(args[1] > 5555 && args[1] <= 6666)
                return "B[+F]%F";
            else if(args[1] > 6666 && args[1] <= 7777)
                return "B[-F]^F";
            else if(args[1] > 7777 && args[1] <= 8888)
                return "B[-F]%F";
            else if(args[1] > 8888 && args[1] <= 10000)
                return "B[+F][-F][%F]^F";
            
        }
        else
            return args[0];
    }
    this.init = function (str, numRecursions) {
        if(numRecursions == 0) {
            return;
        }

        var newStr = "";
        for(var i = 0; i < str.length; i++) {
            newStr += this.rules([str.charAt(i), Math.round(Math.random() * 10000)]);
        }

        this.instructions = newStr;

        this.init(this.instructions, numRecursions - 1);
    }
    this.init(start, recursions);
    this.drawTwig = function (startPos, length, angle) {
        // Line stuff
        var mat = new THREE.LineBasicMaterial({color: 0xff0000});
        var geom = new THREE.BufferGeometry();
        console.log(startPos);
        var newLinePos = [startPos[0] + length * Math.cos(angle), startPos[1] + length * Math.sin(angle)];
        var newLineAngle = angle + angle / 2;
        var vertices = new Float32Array([
            startPos[0], startPos[1], .11,
            newLinePos[0], newLinePos[1], .11
        ]);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

        var line = new THREE.Line(geom, mat);

        scene.add(line);

        geom = new THREE.BufferGeometry();
        vertices = new Float32Array([
            newLinePos[0], newLinePos[1], .11 / 2,
            newLinePos[0] + (length / 2) * Math.cos(newLineAngle), newLinePos[1] + (length / 2) * Math.sin(newLineAngle), .11 / 2
        ]);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

        var newLine = new THREE.Line(geom, mat);

        scene.add(newLine);

        // End line stuff
        

        // Cylinder stuff

        var rad = 0.1;
        mat = new THREE.MeshBasicMaterial({color: 0xffff00});
        geom = new THREE.CylinderGeometry(rad, rad, length, 4);

        var mesh = new THREE.Mesh(geom, mat);

        var newPos = [startPos[0] + (length / 2) * Math.cos(angle), startPos[1] + (length / 2) * Math.sin(angle), 0];
        var newStart = [startPos[0] + length * Math.cos(angle), startPos[1] + length * Math.sin(angle), 0];

        mesh.position.set(newPos[0], newPos[1], newPos[2]);
        mesh.rotation.set(0, 0, -angle);

        scene.add(mesh);

        /*var ptGeom = new THREE.BufferGeometry();
        var newVerts = new Float32Array([
            startPos[0], startPos[1], 0
        ]);
        ptGeom.setAttribute('position', new THREE.BufferAttribute(newVerts, 3));
        var ptMat = new THREE.PointsMaterial( { size: 30, sizeAttenuation: false, color: 0x00ffff} );
        var dot = new THREE.Points( ptGeom, ptMat );
        scene.add( dot );

        ptGeom = new THREE.BufferGeometry();
        newVerts = new Float32Array([
            newStart[0], newStart[1], 0
        ]);
        ptGeom.setAttribute('position', new THREE.BufferAttribute(newVerts, 3));
        var newDot = new THREE.Points( ptGeom, ptMat );
        scene.add( newDot );

        ptGeom = new THREE.BufferGeometry();
        newVerts = new Float32Array([
            newPos[0], newPos[1], 0
        ]);
        ptGeom.setAttribute('position', new THREE.BufferAttribute(newVerts, 3));
        var newDot = new THREE.Points( ptGeom, ptMat );
        scene.add( newDot );*/


        length -= length / 2;
        rad -= rad / 2;
        var displayAngle = angle - angle / 2
        angle += angle / 2;

        console.log("New Start");
        console.log(newStart);

        // Second branch
        mat = new THREE.MeshBasicMaterial({color: 0xff00ff});
        geom = new THREE.CylinderGeometry(rad, rad, length, 4);

        var newMesh = new THREE.Mesh(geom, mat);

        var newNewPos = [newStart[0] + (length / 2) * Math.cos(angle), newStart[1] + (length / 2) * Math.sin(angle), 0];
        
        console.log(newNewPos);

        /*ptGeom = new THREE.BufferGeometry();
        newVerts = new Float32Array([
            newNewPos[0], newNewPos[1], 0
        ]);
        ptGeom.setAttribute('position', new THREE.BufferAttribute(newVerts, 3));
        var newDot = new THREE.Points( ptGeom, ptMat );
        scene.add( newDot );*/

        newMesh.position.set(newNewPos[0], newNewPos[1], newNewPos[2]);
        newMesh.rotation.set(0, 0, -displayAngle);

        scene.add(newMesh);
    }
    this.drawTree = function (deltAngles) {
        console.log("Running drawTree");

        // Angle management
        var deltaAngles = deltAngles;
        function getAngle() {
            return deltaAngles[Math.floor(Math.random() * deltaAngles.length)]; // Since Math.random() is exclusive for 1 (does not include 1), this will work
        }
        var xAngle = 90 * Math.PI / 180;
        var zAngle = 90 * Math.PI / 180;

        // Size / Position management
        var length = 1;
        var rad = .1;
        var lastPos = [0, 0, 0];
        var newPos = [0, 0, 0];

        // Geometry management
        var geom;
        const logMat = new THREE.MeshPhongMaterial({color: 0x4B371C});
        const leafMat = new THREE.MeshPhongMaterial({color: 0x00F400, transparent: true, opacity: 0.8});
        var vertices; // For points

        // Logic management
        var stack = [];

        for(let i = 0; i < this.instructions.length; i++) {
            switch(this.instructions.charAt(i)) {
                case "B":
                case "F":
                    //console.log("Drawing branch");
                    geom = new THREE.CylinderGeometry(rad - rad / 5, rad, length, 16);
                    newPos = [lastPos[0] + length * Math.cos(xAngle), lastPos[1] + length * ((Math.sin(xAngle) + Math.sin(zAngle)) / 2), lastPos[2] + length * Math.cos(zAngle)];

                    var mesh = new THREE.Mesh(geom, logMat);
                    mesh.position.set(lastPos[0] + (length / 2) * Math.cos(xAngle), lastPos[1] + (length / 2) * ((Math.sin(xAngle) + Math.sin(zAngle)) / 2), lastPos[2] + (length / 2) * Math.cos(zAngle));
                    mesh.rotation.set(Math.cos(zAngle), 0, -Math.cos(xAngle));
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;

                    scene.add(mesh);

                    this.group.add(mesh);

                    lastPos = newPos;

                    // Build a leaf if the letter is "F"
                    if(this.instructions.charAt(i) == "F") {
                        geom = new THREE.BoxGeometry(length ** 0.5, length ** 0.5, length ** 0.5); // Create a leaf 2x the size of the radius of the branch
                        mesh = new THREE.Mesh(geom, leafMat);
                        mesh.position.set(lastPos[0] + (length ** 0.5 / 2) * Math.cos(xAngle), lastPos[1] + (length ** 0.5 / 2) * ((Math.sin(xAngle) + Math.sin(zAngle)) / 2), lastPos[2] + (length ** 0.5 / 2) * Math.cos(zAngle));
                        mesh.rotation.set(Math.cos(zAngle), 0, -Math.cos(xAngle));
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        scene.add(mesh);
                        
                        this.group.add(mesh);
                    }
                    break;
                case "+": // Increase xAngle
                    //console.log("Increasing angle");
                    var deltaAngle = getAngle() * Math.PI / 180;
                    xAngle += deltaAngle;
                    length -= length / 4;
                    rad -= rad / 5;
                    break;
                case "-": // Decrease xAngle
                    //console.log("Decreasing angle");
                    var deltaAngle = getAngle() * Math.PI / 180;
                    xAngle -= deltaAngle;
                    length -= length / 4;
                    rad -= rad / 5;
                    break;
                case "^": // Increase zAngle
                    //console.log("Decreasing angle");
                    var deltaAngle = getAngle() * Math.PI / 180;
                    zAngle += deltaAngle;
                    length -= length / 4;
                    rad -= rad / 5;
                    break;
                case "%": // Decrease zAngle
                    //console.log("Decreasing angle");
                    var deltaAngle = getAngle() * Math.PI / 180;
                    zAngle -= deltaAngle;
                    length -= length / 4;
                    rad -= rad / 5;
                    break;
                case "[":
                    //console.log("Pushed to stack");
                    stack.push([lastPos, xAngle, zAngle, length, rad]);
                    break;
                case  "]":
                    //console.log("Popped from stack");
                    var values = stack.pop();
                    lastPos = values[0];
                    xAngle = values[1];
                    zAngle = values[2];
                    length = values[3];
                    rad = values[4];
            }
        }

        scene.add(this.group);
    }
}

/**
var tree = new Tree("B", 4);
//tree.drawTwig([0,0], 35, Math.PI / 4);
//tree.instructions = "B[+F]-F"
tree.drawTree([20, 35, 45, 60, /*90, 110, 130]);
//tree.group.position.set(5, -2, -5);
tree.group.position.set(0, -2, 0);

var tree2 = new Tree("B", 4);
tree2.drawTree([20, 35, 45]);
tree2.group.position.set(5, -2, -5);

var tree3 = new Tree("B", 4);
tree3.drawTree([20, 35, 45]);
tree3.group.position.set(1, -2, -4);


var tree4 = new Tree("B", 4);
tree4.drawTree([20, 35, 45]);
tree4.group.position.set(-3, -2, -7);
*/

/**
 * Adding in the terrain
 * 
 */

 // Define the 2D array
 // 2^12,
const terrainSize = 128; 
var terrain = [];
for(var i = 0; i < terrainSize + 1; i++) {
    terrain[i] = new Array(terrainSize + 1);
    for(var j = 0; j < terrainSize + 1; j++) {
        terrain[i][j] = -1;
    }
}

// Define 4 corners
terrain[0][0] = 100; // TL
terrain[terrainSize][0] = 130; // TR
terrain[0][terrainSize] = 200; // BL
terrain[terrainSize][terrainSize] = 160; // BR

var lowRange = 0;
var highRange = 1000;

// Define center
terrain[terrainSize/2][terrainSize/2] = getRandomArbitraryInt(highRange/2, highRange);

// Define random points center

/**
terrain[32][64] = 1000;
terrain[24][56] = 670;
terrain[64][96] = 600;
**/

// Loops through every point.
for(var i = 0; i < terrainSize; i++) {
    for(var j = 0; j < terrainSize; j++) {
        
        var random = getRandomArbitraryInt(0,10);

        if(random > 7 && random < 8) {
            terrain[i][j] = getRandomArbitraryInt(0,50);
        } else if ( random > 8 ) {
            terrain[i][j] = getRandomArbitraryInt(50,200);
        }
        

    }
}

//console.log(terrain);

// Perform the fractilized smoothing
console.log("Before");
console.log(terrain);

doFractile(terrain, [0,0], [terrainSize,0], [0,terrainSize], [terrainSize,terrainSize]);

console.log("After");
console.log(terrain);

// Map the heights to a geometry
var geom = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSize, terrainSize);
var mat = new THREE.MeshPhongMaterial({color: new THREE.Color("orange"), side: THREE.DoubleSide});

var verts = [];

for(var i = 0; i < (terrainSize+1)**2; i++) {
    verts[i] = terrain[i % (terrainSize+1)][Math.floor(i / (terrainSize+1))];
}

console.log("Verts of Geom");
console.log(verts);

console.log(geom);

for ( var i = 0; i < geom.vertices.length; i++ ) {
    geom.vertices[i].z = verts[i] * 0.02;
}


geom.verticesNeedUpdate = true;
geom.computeFaceNormals();
geom.computeVertexNormals();

function doFractile(ter, tl, tr, bl, br) {

    // Base case
    if(tl[0] + 1 == tr[0] || tl[0] + 1 == bl[0])
        return;

    var center = [(tl[0] + tr[0]) / 2, (tl[1] + bl[1]) / 2];
    
    if(ter[center[0]][center[1]] == -1) { // If no center value is present, compute center
        ter[center[0]][center[1]] = (
            ter[tl[0]][tl[1]] +
            ter[tr[0]][tr[1]] +
            ter[bl[0]][bl[1]] +
            ter[br[0]][br[1]]
        ) / 4;
    }
    // Compute sides
    // Left
    var left = [tl[0], center[1]];
    if(ter[left[0]][left[1]] == -1)
        ter[left[0]][left[1]] = (ter[tl[0]][tl[1]] + ter[bl[0]][bl[1]]) / 2; // Avg of tl and bl
    // Right
    var right = [tr[0], center[1]];
    if(ter[right[0]][right[1]] == -1)
        ter[right[0]][right[1]] = (ter[tr[0]][tr[1]] + ter[br[0]][br[1]]) / 2; // Avg of tr and br
    // Top
    var top = [center[0], tl[1]];
    if(ter[top[0]][top[1]] == -1)
        ter[top[0]][top[1]] = (ter[tl[0]][tl[1]] + ter[tr[0]][tr[1]]) / 2; // Avg of tl and tr
    // Bottom
    var bottom = [center[0], bl[1]];
    if(ter[bottom[0]][bottom[1]] == -1)
        ter[bottom[0]][bottom[1]] = (ter[bl[0]][bl[1]] + ter[br[0]][br[1]]) / 2; // Avg of bl and br

    // Call for four quadrants
    doFractile(ter, tl, top, left, center);       // Top left quadrant
    doFractile(ter, top, tr, center, right);      // Top right quadrant
    doFractile(ter, left, center, bl, bottom);    // Bottom left quadrant
    doFractile(ter, center, right, bottom, br);   // Bottom right quadrant
    
}

var plane = new THREE.Mesh(geom, mat);

plane.rotation.x -= Math.PI / 2;

plane.castShadow = true;
plane.receiveShadow = true;

scene.add(plane);


// Adding in the sun and the moon geometries and rotations
const pD = 100;
const loader = new THREE.TextureLoader();
var sunGroup = new THREE.Group();
var moonGroup = new THREE.Group();
var orbit = new THREE.Group();

var planetGeometry = new THREE.SphereGeometry( 10, 32, 16 );
var sunMesh = new THREE.MeshBasicMaterial( { color: 0xffff00, map: loader.load('./media/sun.png') } );
var moonMesh = new THREE.MeshBasicMaterial( { color: 0xffff00, map: loader.load('./media/moon.png') } );

var sun = new THREE.Mesh( planetGeometry, sunMesh );
var moon = new THREE.Mesh( planetGeometry, moonMesh );

const color = 0xFFFFFF;
const intensity = 1;
var sunLight = new THREE.DirectionalLight(color, intensity);
sunLight.target.position.set(0, 0, 0);
sunGroup.add( sun );
sunGroup.add( sunLight );
sunGroup.position.set(pD, pD, pD);

const moonColor = 0xd8e9f7;
const moonIntensity = 0.75;
var moonLight = new THREE.DirectionalLight(moonColor, moonIntensity);
moonLight.target.position.set(0, 0, 0);
moonGroup.add( moonLight );
moonGroup.add( moon );
moonGroup.position.set(-pD, -pD, -pD);

orbit.add( moonGroup );
orbit.add( sunGroup );

scene.add( orbit );

// Keyboard Input Listener
document.addEventListener('keydown', (e) => {
    if(e.key === "a") {/*Do nothing for now*/}
});

var clock = new THREE.Clock();
var speed = 10; //units a second
var delta = 0;
var pos = 0;

// Does the animation
//  - Currently moves the sun and moon at 15 degrees per seccond. 
function animate() {
    requestAnimationFrame(animate);

    // Moves the sun and moon in a rotation.
    delta = clock.getDelta();
    pos += delta;
    if(pos >= 0.25) {

        orbit.rotation.z += 0.01; 
        console.log(orbit);

        pos = 0;
    }

    console.log(delta);

    render();
}

function render() {
    renderer.render(scene, camera);
}

// Initiate graphical loop
animate();

    </script>

</body>
</html>
