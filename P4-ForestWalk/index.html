<html>
<head>
    <title>Derek Costello Practice 9.4</title>
</head>
<body>

    <canvas id="myCanvas"></canvas>

<script type="module">
import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
import { OrbitControls } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/OrbitControls.js";

// Define scene
var scene = new THREE.Scene();

// Camera
var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.set(0, 0, 10);
camera.lookAt( new THREE.Vector3(0.0,0.0,0.0));
scene.add( camera );

// Define renderer
var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;

const controls = new OrbitControls(camera, renderer.domElement);

function Tree(start, recursions) {
    this.group = new THREE.Group();
    this.instructions = "";
    this.rules = function (args){
        if(args[0] == "B") {
            if(args[1] <= 1500) // 15% chance of BB
                return "BB";
            else if(args[1] > 1500 && args[1] <= 3625) // 16.25% chance for each other rule
                return "B[+F]";
            else if(args[1] > 3625 && args[1] <= 5750)
                return "B[-F]";
            else if(args[1] > 5750 && args[1] <= 7875)
                return "B[^F]";
            else if(args[1] > 7875 && args[1] <= 10000)
                return "B[%F]";
        }
        else if(args[0] == "F") {
            if(args[1] <= 3333) // 33.33% chance of F
                return "F";
            else if(args[1] > 3333 && args[1] <= 4444) // 11.11% chance for each other rule
                return "B[+F]-F";
            else if(args[1] > 4444 && args[1] <= 5555)
                return "B[+F]^F";
            else if(args[1] > 5555 && args[1] <= 6666)
                return "B[+F]%F";
            else if(args[1] > 6666 && args[1] <= 7777)
                return "B[-F]^F";
            else if(args[1] > 7777 && args[1] <= 8888)
                return "B[-F]%F";
            else if(args[1] > 8888 && args[1] <= 10000)
                return "B[+F][-F][%F]^F";
            
        }
        else
            return args[0];
    }
    this.init = function (str, numRecursions) {
        if(numRecursions == 0) {
            return;
        }

        var newStr = "";
        for(var i = 0; i < str.length; i++) {
            newStr += this.rules([str.charAt(i), Math.round(Math.random() * 10000)]);
        }

        this.instructions = newStr;

        this.init(this.instructions, numRecursions - 1);
    }
    this.init(start, recursions);
    this.drawTwig = function (startPos, length, angle) {
        // Line stuff
        var mat = new THREE.LineBasicMaterial({color: 0xff0000});
        var geom = new THREE.BufferGeometry();
        console.log(startPos);
        var newLinePos = [startPos[0] + length * Math.cos(angle), startPos[1] + length * Math.sin(angle)];
        var newLineAngle = angle + angle / 2;
        var vertices = new Float32Array([
            startPos[0], startPos[1], .11,
            newLinePos[0], newLinePos[1], .11
        ]);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

        var line = new THREE.Line(geom, mat);

        scene.add(line);

        geom = new THREE.BufferGeometry();
        vertices = new Float32Array([
            newLinePos[0], newLinePos[1], .11 / 2,
            newLinePos[0] + (length / 2) * Math.cos(newLineAngle), newLinePos[1] + (length / 2) * Math.sin(newLineAngle), .11 / 2
        ]);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

        var newLine = new THREE.Line(geom, mat);

        scene.add(newLine);

        // End line stuff
        

        // Cylinder stuff

        var rad = 0.1;
        mat = new THREE.MeshBasicMaterial({color: 0xffff00});
        geom = new THREE.CylinderGeometry(rad, rad, length, 4);

        var mesh = new THREE.Mesh(geom, mat);

        var newPos = [startPos[0] + (length / 2) * Math.cos(angle), startPos[1] + (length / 2) * Math.sin(angle), 0];
        var newStart = [startPos[0] + length * Math.cos(angle), startPos[1] + length * Math.sin(angle), 0];

        mesh.position.set(newPos[0], newPos[1], newPos[2]);
        mesh.rotation.set(0, 0, -angle);

        scene.add(mesh);

        /*var ptGeom = new THREE.BufferGeometry();
        var newVerts = new Float32Array([
            startPos[0], startPos[1], 0
        ]);
        ptGeom.setAttribute('position', new THREE.BufferAttribute(newVerts, 3));
        var ptMat = new THREE.PointsMaterial( { size: 30, sizeAttenuation: false, color: 0x00ffff} );
        var dot = new THREE.Points( ptGeom, ptMat );
        scene.add( dot );

        ptGeom = new THREE.BufferGeometry();
        newVerts = new Float32Array([
            newStart[0], newStart[1], 0
        ]);
        ptGeom.setAttribute('position', new THREE.BufferAttribute(newVerts, 3));
        var newDot = new THREE.Points( ptGeom, ptMat );
        scene.add( newDot );

        ptGeom = new THREE.BufferGeometry();
        newVerts = new Float32Array([
            newPos[0], newPos[1], 0
        ]);
        ptGeom.setAttribute('position', new THREE.BufferAttribute(newVerts, 3));
        var newDot = new THREE.Points( ptGeom, ptMat );
        scene.add( newDot );*/


        length -= length / 2;
        rad -= rad / 2;
        var displayAngle = angle - angle / 2
        angle += angle / 2;

        console.log("New Start");
        console.log(newStart);

        // Second branch
        mat = new THREE.MeshBasicMaterial({color: 0xff00ff});
        geom = new THREE.CylinderGeometry(rad, rad, length, 4);

        var newMesh = new THREE.Mesh(geom, mat);

        var newNewPos = [newStart[0] + (length / 2) * Math.cos(angle), newStart[1] + (length / 2) * Math.sin(angle), 0];
        
        console.log(newNewPos);

        /*ptGeom = new THREE.BufferGeometry();
        newVerts = new Float32Array([
            newNewPos[0], newNewPos[1], 0
        ]);
        ptGeom.setAttribute('position', new THREE.BufferAttribute(newVerts, 3));
        var newDot = new THREE.Points( ptGeom, ptMat );
        scene.add( newDot );*/

        newMesh.position.set(newNewPos[0], newNewPos[1], newNewPos[2]);
        newMesh.rotation.set(0, 0, -displayAngle);

        scene.add(newMesh);
    }
    this.drawTree = function (deltAngles) {
        console.log("Running drawTree");

        // Angle management
        var deltaAngles = deltAngles;
        function getAngle() {
            return deltaAngles[Math.floor(Math.random() * deltaAngles.length)]; // Since Math.random() is exclusive for 1 (does not include 1), this will work
        }
        var xAngle = 90 * Math.PI / 180;
        var zAngle = 90 * Math.PI / 180;

        // Size / Position management
        var length = 1;
        var rad = .1;
        var lastPos = [0, 0, 0];
        var newPos = [0, 0, 0];

        // Geometry management
        var geom;
        const logMat = new THREE.MeshPhongMaterial({color: 0x4B371C});
        const leafMat = new THREE.MeshPhongMaterial({color: 0x00F400, transparent: true, opacity: 0.8});
        var vertices; // For points

        // Logic management
        var stack = [];

        for(let i = 0; i < this.instructions.length; i++) {
            switch(this.instructions.charAt(i)) {
                case "B":
                case "F":
                    //console.log("Drawing branch");
                    geom = new THREE.CylinderGeometry(rad - rad / 5, rad, length, 16);
                    newPos = [lastPos[0] + length * Math.cos(xAngle), lastPos[1] + length * ((Math.sin(xAngle) + Math.sin(zAngle)) / 2), lastPos[2] + length * Math.cos(zAngle)];

                    var mesh = new THREE.Mesh(geom, logMat);
                    mesh.position.set(lastPos[0] + (length / 2) * Math.cos(xAngle), lastPos[1] + (length / 2) * ((Math.sin(xAngle) + Math.sin(zAngle)) / 2), lastPos[2] + (length / 2) * Math.cos(zAngle));
                    mesh.rotation.set(Math.cos(zAngle), 0, -Math.cos(xAngle));
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;

                    scene.add(mesh);

                    this.group.add(mesh);

                    lastPos = newPos;

                    // Build a leaf if the letter is "F"
                    if(this.instructions.charAt(i) == "F") {
                        geom = new THREE.BoxGeometry(length ** 0.5, length ** 0.5, length ** 0.5); // Create a leaf 2x the size of the radius of the branch
                        mesh = new THREE.Mesh(geom, leafMat);
                        mesh.position.set(lastPos[0] + (length ** 0.5 / 2) * Math.cos(xAngle), lastPos[1] + (length ** 0.5 / 2) * ((Math.sin(xAngle) + Math.sin(zAngle)) / 2), lastPos[2] + (length ** 0.5 / 2) * Math.cos(zAngle));
                        mesh.rotation.set(Math.cos(zAngle), 0, -Math.cos(xAngle));
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        scene.add(mesh);
                        
                        this.group.add(mesh);
                    }
                    break;
                case "+": // Increase xAngle
                    //console.log("Increasing angle");
                    var deltaAngle = getAngle() * Math.PI / 180;
                    xAngle += deltaAngle;
                    length -= length / 4;
                    rad -= rad / 5;
                    break;
                case "-": // Decrease xAngle
                    //console.log("Decreasing angle");
                    var deltaAngle = getAngle() * Math.PI / 180;
                    xAngle -= deltaAngle;
                    length -= length / 4;
                    rad -= rad / 5;
                    break;
                case "^": // Increase zAngle
                    //console.log("Decreasing angle");
                    var deltaAngle = getAngle() * Math.PI / 180;
                    zAngle += deltaAngle;
                    length -= length / 4;
                    rad -= rad / 5;
                    break;
                case "%": // Decrease zAngle
                    //console.log("Decreasing angle");
                    var deltaAngle = getAngle() * Math.PI / 180;
                    zAngle -= deltaAngle;
                    length -= length / 4;
                    rad -= rad / 5;
                    break;
                case "[":
                    //console.log("Pushed to stack");
                    stack.push([lastPos, xAngle, zAngle, length, rad]);
                    break;
                case  "]":
                    //console.log("Popped from stack");
                    var values = stack.pop();
                    lastPos = values[0];
                    xAngle = values[1];
                    zAngle = values[2];
                    length = values[3];
                    rad = values[4];
            }
        }

        scene.add(this.group);
    }
}

var tree = new Tree("B", 4);
//tree.drawTwig([0,0], 35, Math.PI / 4);
//tree.instructions = "B[+F]-F"
tree.drawTree([20, 35, 45/*, 60, 90, 110, 130*/]);
//tree.group.position.set(5, -2, -5);
tree.group.position.set(0, -2, 0);

var tree2 = new Tree("B", 4);
tree2.drawTree([20, 35, 45]);
tree2.group.position.set(5, -2, -5);

var tree3 = new Tree("B", 4);
tree3.drawTree([20, 35, 45]);
tree3.group.position.set(1, -2, -4);


var tree4 = new Tree("B", 4);
tree4.drawTree([20, 35, 45]);
tree4.group.position.set(-3, -2, -7);

// Adding in the sun and the moon geometries and rotations
const pD = 100;
const loader = new THREE.TextureLoader();
var sunGroup = new THREE.Group();
var moonGroup = new THREE.Group();
var orbit = new THREE.Group();

var planetGeometry = new THREE.SphereGeometry( 10, 32, 16 );
var sunMesh = new THREE.MeshBasicMaterial( { color: 0xffff00, map: loader.load('./media/sun.png') } );
var moonMesh = new THREE.MeshBasicMaterial( { color: 0xffff00, map: loader.load('./media/moon.png') } );

var sun = new THREE.Mesh( planetGeometry, sunMesh );
var moon = new THREE.Mesh( planetGeometry, moonMesh );

const color = 0xFFFFFF;
const intensity = 1;
var sunLight = new THREE.DirectionalLight(color, intensity);
sunLight.target.position.set(0, 0, 0);
sunGroup.add( sun );
sunGroup.add( sunLight );
sunGroup.position.set(pD, pD, pD);

moonGroup.add( moon );
moonGroup.position.set(-pD, -pD, -pD);

orbit.add( moonGroup );
orbit.add( sunGroup );

scene.add( orbit );

// Keyboard Input Listener
document.addEventListener('keydown', (e) => {
    if(e.key === "a") {/*Do nothing for now*/}
});

var clock = new THREE.Clock();
var speed = 10; //units a second
var delta = 0;
var pos = 0;

// Does the animation
//  - Currently moves the sun and moon at 15 degrees per seccond. 
function animate() {
    requestAnimationFrame(animate);

    // Moves the sun and moon in a rotation.
    delta = clock.getDelta();
    pos += delta;
    if(pos >= 0.25) {

        orbit.rotation.z += 0.01; 
        console.log(orbit);

        pos = 0;
    }

    console.log(delta);

    render();
}

function render() {
    renderer.render(scene, camera);
}

// Initiate graphical loop
animate();

    </script>

</body>
</html>
