<!DOCTYPE html>
<html>

<head>
	<script src="/js/three.js"></script>
	<script type="text/javascript" src="/js/physi.js"></script>
	<script type="text/javascript" src="/js/OrbitControls.js"></script>
    <script type="text/javascript" src="/js/Dummy.js"></script>
	
</head>

<body>
	<div id="viewport"></div>

<script type="text/javascript">
	
	'use strict';
	
	Physijs.scripts.worker = '/js/physijs_worker.js';
	Physijs.scripts.ammo = '/js/ammo.js';
	
	var initScene, render, renderer, scene, camera, box, sphere1, sphere2, spring, dummy1, dummy2, dummy3;
	
	initScene = function() {
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setClearColor(0x000000);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
		document.getElementById( 'viewport' ).appendChild( renderer.domElement );
		
		scene = new Physijs.Scene;
		
		camera = new THREE.PerspectiveCamera(
			35,
			window.innerWidth / window.innerHeight,
			1,
			5000
		);
		camera.position.set( 60, 50, 60 );
		camera.lookAt( scene.position );
		scene.add( camera );

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Add the directional light
        const dirLight = new THREE.DirectionalLight(0xffffff);
        const backLight = new THREE.DirectionalLight(0x212121);

        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.position.set(20, 30, 15);

        backLight.position.set(-20, -30, -15);
        scene.add(dirLight);
        scene.add(backLight);
		
		/* Box
		box = new Physijs.BoxMesh(
			new THREE.CubeGeometry( 5, 5, 5 ),
			new THREE.MeshPhongMaterial({ color: 0x888888 }),
            2
		);
		scene.add( box );
        //*/

        // Plane
        var planeGeom = new THREE.PlaneGeometry(320, 320);
        var planeBaseMat = new THREE.MeshPhongMaterial({color: 0xffffff, side: THREE.DoubleSide});
        var planeCoverMat = Physijs.createMaterial(new THREE.MeshPhongMaterial({color: 0xffff00, side: THREE.DoubleSide}), 1, 1);
        const planeBase = new Physijs.ConvexMesh(planeGeom, planeBaseMat, 0);
        const planeCover = new Physijs.ConvexMesh(planeGeom, planeCoverMat, 10000);
        planeBase.position.set(0, -10, 0);
        planeBase.rotation.x = Math.PI / 2;
        planeCover.position.set(0, -9.99, 0);
        planeCover.rotation.x = Math.PI / 2;
        planeCover.receiveShadow = true;

        scene.add(planeBase);
        scene.add(planeCover);

        // Dummy
        dummy1 = new Dummy(new THREE.Vector3(0, 0, 0), Math.random() * 0xffffff, 25);
        dummy1.init(scene);

        dummy2 = new Dummy(new THREE.Vector3(20, 0, 20), Math.random() * 0xffffff, 2);
        dummy2.init(scene);

        dummy3 = new Dummy(new THREE.Vector3(-20, 0, 20), Math.random() * 0xffffff, 2);
        dummy3.init(scene);

        // Add arrow helpers
        const xArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(), 20, 0xff0000);
        const yArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(), 20, 0x8800ff);
        const zArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(), 20, 0x0088ff);

        xArrow.position.set(0, 10, 0);
        yArrow.position.set(0, 10, 0);
        zArrow.position.set(0, 10, 0);
        
        scene.add(xArrow);
        scene.add(yArrow);
        scene.add(zArrow);

		requestAnimationFrame( render );
	};

    // Got function from https://codepen.io/anon/pen/qNNNzJ
    window.addEventListener('resize', function(e){
        var width = window.innerWidth, height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        renderer.render(scene, camera);
    });
    
    document.addEventListener("keydown", (e) => {
        if(e.key == 'w') {
            dummy1.leftForearm.applyImpulse(new THREE.Vector3(0, 0, -1000), new THREE.Vector3(0, -3.5, 0));
        } else if(e.key == 'a') {
            dummy1.leftForearm.applyCentralImpulse(new THREE.Vector3(-1000, 0, 0));
        } else if(e.key == 's') {
            dummy1.leftForearm.applyCentralImpulse(new THREE.Vector3(0, 0, 1000));
        } else if(e.key == 'd') {
            dummy1.leftForearm.applyCentralImpulse(new THREE.Vector3(1000, 0, 0));
        } else if(e.ctrlKey) {
            dummy1.leftForearm.applyCentralImpulse(new THREE.Vector3(0, -500, 0));
        } else if(e.shiftKey) {
            dummy1.leftForearm.applyCentralImpulse(new THREE.Vector3(0, 1000, 0));
        }
    });
	
	render = function() {
        //spring.updateSpringForce();
		scene.simulate(); // run physics
		renderer.render( scene, camera); // render the scene
		requestAnimationFrame( render );
	};
	
	window.onload = initScene();

    </script>
</body>
</html>