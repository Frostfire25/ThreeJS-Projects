<html>
<head>
    <title> Final Project - Alexander Elguezabal - Derek Costello </title>
</head>
<body>

    <canvas id="myCanvas"></canvas>

<script id = "vertexShader" type = "x-shader/x-vertex">
// Shift vertex position along normal

uniform sampler2D bumpTexture; // bump texture is lookup in texture image
uniform float bumpScale; // amount vertex is displaced by the bumpTexture

// varying = data to be shared with fragment shader
varying float vAmount; // Red color value in a texel.

void main() {
    vec4 bumpData = texture2D( bumpTexture, uv ); // color value of the texel/cordonate
    vAmount = bumpData.r; // get the red value of the texel art

    // move the position along the normal (direction of the vertex)
    vec3 newPosition = position + normal * bumpScale * vAmount;

    // Calculate new position of vertex
    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
}
</script>

<script id = "fragmentShader" type = "x-shader/x-vertex">
// operates on "fragment of an object and tells what the color of the fragment is supposed to be.

// varying is a variable that contains data from the vertex shader to the fragment shader.
varying float vAmount; // Received from vertex shader, represents the red value of a texel.

void main() {
    //                  Color Gradient main                    Color Gradient Edge      
    //                      minHt maxHt mapHt                  minHt maxHt mapHt             RGB color
    vec3 water = (smoothstep(0.01, 0.99, vAmount/0.9) - smoothstep(0.15, 0.16, vAmount)) * vec3(0.0, 0.10, 0.75);
    
    // Sand gradient.
    vec3 sand = (smoothstep(0.15, 0.16, vAmount) - smoothstep(0.16, 0.18, vAmount)) * vec3(0.8, 0.7, 0.5);

    // Grass layer
    vec3 grass = (smoothstep(0.16, 0.20, vAmount) - smoothstep(0.18, 0.30, vAmount)) * vec3(0.01, 0.5, 0.2);
    
    // Dirt layer
    vec3 dirt = (smoothstep(0.20, 0.34, vAmount) - smoothstep(0.30, 0.42, vAmount)) * vec3(0.4, 0.25, 0.21);

    // Dirt2 layer
    vec3 dirt2 = (smoothstep(0.34, 0.52, vAmount) - smoothstep(0.42, 0.65, vAmount)) * vec3(0.45, 0.35, 0.31);

    // Dirt3 layer
    vec3 dirt3 = (smoothstep(0.52, 0.67, vAmount) - smoothstep(0.65, 0.75, vAmount)) * vec3(0.55, 0.45, 0.37);
    
    // Dirt4 layer
    vec3 dirt4 = (smoothstep(0.67, 0.78, vAmount) - smoothstep(0.75, 0.82, vAmount)) * vec3(0.65, 0.75, 0.42);

    // Dirt5 layer
    vec3 dirt5 = (smoothstep(0.74, 0.84, vAmount) - smoothstep(0.82, 0.93, vAmount)) * vec3(0.75, 0.85, 0.5);

    // Snow layer
    vec3 snow = (smoothstep(0.84, 0.94, vAmount) - smoothstep(0.93, 0.97, vAmount)) * vec3(0.99, 0.99, 0.99);

    // Ice layer
    vec3 ice = (smoothstep(0.93, 0.99, vAmount) - smoothstep(0.97, 0.9999, vAmount)) * vec3(0.87, 0.87, 0.99);

    gl_FragColor = vec4( ice + snow + dirt5 + dirt4 + dirt3 + dirt2 + dirt + grass + sand + water, 1.0 );
}
</script>

<script type="module">


/**
 * Forest Walk Project
 * By:
 *  - Derek Costello
 *  - Alexander Elguezabal
 * 
 *  WASD keys to move around
 *  Moving the mouse pans your vision
 * 
 *  To view the sun press(o)
 *  To view the moon press(p)
 */ 

import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
import { OrbitControls } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/OrbitControls.js";
import { PointerLockControls } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/PointerLockControls.js";
//import { MeshSurfaceSampler } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/MeshSurfaceSampler.js";
//import RAPIER from 'https://cdn.skypack.dev/@dimforge/rapier2d-compat';


/**
 * Utility Methods
 */ 

// Objects & Functions
// Gets a random number
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}

// Gets a random integer
// https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range
function getRandomArbitraryInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}


// Define scene
var scene = new THREE.Scene();

// Define texture loader
const loader = new THREE.TextureLoader();

// Camera
var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight * 2, .1, 3000 );
camera.position.set(0,200,0);
scene.add( camera );

// Define renderer
var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.outputEncoding = THREE.sRGBEncoding;

// Got function from https://codepen.io/anon/pen/qNNNzJ
window.addEventListener('resize', function(e){
  var width = window.innerWidth, height = window.innerHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
  renderer.render(scene, camera);
});

//const controls = new PointerLockControls( camera, document.body );

let light = new THREE.AmbientLight(0xffffff, 1);
light.position.set(100,100,100);
scene.add(light);

// Adding in orbit controls
const controls = new PointerLockControls( camera, document.body );
//const controls = new OrbitControls( camera, renderer.domElement );

/**
 * Create the heightmap
 * Inspiration from https://www.youtube.com/watch?v=wULUAhckH9w & https://www.youtube.com/watch?v=G0hWjD0n46c&t=43s
 */ 
let terrain = undefined;
const terrainSize = 2000;
const bumpScale = terrainSize/10;
function loadHeightMap() {

    // Load texture and create geometry
    const bumpTexture = new THREE.TextureLoader().load( './media/height_map_1.jpg' )
    const groundGeo = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSize/10, terrainSize/10);
    groundGeo.verticesNeedUpdate = true;
    groundGeo.computeFaceNormals();
    groundGeo.computeVertexNormals();

    // Make the texture wrap or repeate, to wrap do [1,1]
    bumpTexture.wrapS = bumpTexture.wrapT = THREE.Repeating;
    bumpTexture.repeat.set( 1, 1 );

    // Create uniforms to send to the shaders.
    const uniforms = {
        bumpTexture: { value: bumpTexture },
        bumpScale: { value: bumpScale }, // Higher the number, the more the mesh verticies will be displaced.
    };

    // Create the ground material
    const groundMat = new THREE.ShaderMaterial({ 
        uniforms: uniforms,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
    });

    /**
    const groundMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        wireframe: true,
        displacementMap: bumpTexture,
        displacementScale: bumpScale, // Higher the number, the more the mesh verticies will be displaced.
    });
    **/

    groundGeo.verticesNeedUpdate = true;
    groundGeo.computeFaceNormals();
    groundGeo.computeVertexNormals();
    // Creating the ground mesh
    terrain = new THREE.Mesh( groundGeo, groundMat );
    scene.add( terrain );
    terrain.rotation.x = -Math.PI/2;
    terrain.position.y = 20;    
}
// Loading in the height map & texture
loadHeightMap();

/**
 * Adding in grid sky
 */
// Adding sky background.
// Assistance and method from https://www.youtube.com/watch?v=oqKzxPMLWxo &
// https://www.youtube.com/watch?v=cp-H_6VODko
const skyLoader = new THREE.CubeTextureLoader();
const texture = skyLoader.load([
      './media/skybox/dust_ft.jpg',
      './media/skybox/dust_bk.jpg',
      './media/skybox/dust_up.jpg',
      './media/skybox/dust_dn.jpg',
      './media/skybox/dust_rt.jpg',
      './media/skybox/dust_lf.jpg',
  ]);
texture.encoding = THREE.sRGBEncoding;
scene.background = texture;



/**
 * Camera movement 
 */ 
/* Mouse Moving
Got assistance from https://stackoverflow.com/questions/37837189/turning-around-using-mouse-in-three-js
*/
var startX, startY;
function downClbk(e) {
  renderer.domElement.addEventListener('mousemove', moveClbk);
  startX = e.clientX; startY = e.clientY;
}
function upClbk(e) {
  renderer.domElement.removeEventListener('mousemove', moveClbk);
}
function moveClbk(e) {
  var delX = e.clientX - startX;
  var delY = e.clientY - startY;
  var width = window.innerWidth, height = window.innerHeight, min = Math.min(width, height);
  camera.rotation.x += delY/min;
  camera.rotation.y += delX/min;
  startX = e.clientX; startY = e.clientY;
  //renderer.render(scene, camera);
}
renderer.domElement.addEventListener('mousedown', downClbk);
renderer.domElement.addEventListener('mouseup', upClbk);

renderer.domElement.addEventListener('click', mouseClick);
function mouseClick(e) {
    controls.lock();
}


/**
 * KeyPress Events & Walking
 */ 

// Keyboard Input Listener
document.addEventListener('keydown', (e) => {
    moveCamera(e.key);
});

const raycaster = new THREE.Raycaster();
// Moves the camera based on the input direction
function moveCamera( direction ) {
    const moveSpeed = 0.5;
    const halfTerrain = (terrainSize/2);
    const sendBackMoveSpeedMultiplier = 5;

    // If out of bounds return
    if(camera.position.x > (halfTerrain - moveSpeed)) {
        // send two back
        camera.position.x = halfTerrain - (moveSpeed * sendBackMoveSpeedMultiplier);
    } else if(camera.position.x < -1 * (halfTerrain - moveSpeed)) {
        camera.position.x = halfTerrain + (moveSpeed * sendBackMoveSpeedMultiplier);
    } else if(camera.position.z > (halfTerrain - moveSpeed)) {
        camera.position.z = halfTerrain - (moveSpeed * sendBackMoveSpeedMultiplier);
    } else if(camera.position.z < -1 * (halfTerrain - moveSpeed)) {
        camera.position.z = halfTerrain + (moveSpeed * sendBackMoveSpeedMultiplier);
    }
    
    // If hitting a tree return

    // Tree collision detection
    //for(var i = 0; i < trees.length; i++) {
    //    if(isColliding(camera, trees[i].group)) {
    //        camera.translateZ(moveSpeed * sendBackMoveSpeedMultiplier);
    //        console.log("Collission with tree.");
    //    }
    //}

    //var vector = new THREE.Vector3(); // create once and reuse it!
    //camera.getWorldDirection( vector );
    //console.log(vector);

    console.log(terrain);

    // Move in the direction
    switch( direction ) {
        case 'w': {
            camera.translateZ(-moveSpeed);            
        }; break;
        case 'a': {
            camera.translateX(-moveSpeed);
        }; break;
        case 's': {
            camera.translateZ(moveSpeed);
        }; break;
        case 'd': {
            camera.translateX(moveSpeed);
        }; break;
    }    
    // Change camera y according to raycasting
    raycaster.set(camera.position, new THREE.Vector3(0, -1, 0).normalize());
    const intersects = raycaster.intersectObject( terrain );

    // If we do not interset, go up and try again
    if(intersects.length <= 0) {

    } 
    // We have an intersection, use 0
    else {
        console.log(intersects);
        camera.position.y = (camera.position.y - intersects[0].distance) + 2;
    }

    render();
}






// Does the animation
function animate() {
    requestAnimationFrame(animate);
    //controls.update();


    render();
}

function render() {
    renderer.render(scene, camera);
}


// Initiate graphical loop
animate();

    </script>

</body>
</html>
